# To let the tomcat installation have use local properties which are not in git
# for sensitive values the values MUST NOT appear here because the only way to specify
# the local property file is not able to override the values in application.properties
falc.account.db.name=${local.falc.account.db.name:accountH2create}
falc.account.db.location=${local.falc.account.db.location:./db}
falc.account.db.usernamee=${local.falc.account.db.username:sa}
falc.account.db..password=${local.falc.account.db.password:password}
falc.account.db.cron=${local.falc.account.db.cron:0 45 2 * * ?}
falc.account.standingorder.cron=${local.falc.account.standingorder.cron:0 5 */4 * * ?}

falc.account.name=JAccount
falc.account.db=H2
falc.account.version=0.5.1c
#   second
#   minute
#   hour
#   day of month
#   month
#   day of week
# "0 10 08 * * ?"  08:10 every day
# "*/10 * * * * *" every 10 seconds
#                               s m  h  d m 
#falc.account.standingorder.cron=0 10 08 * * ?

# NORMAL (default) or SORTED
falc.account.transaction.listsort=SORTED

spring.application.name=accountapi

spring.jpa.show-sql=false
spring.jpa.properties.hibernate.show_sql=false

# Still haven't found a way to provide installation dependent configuration, eg. specify the production location
# of the DB on the production system independently of the installed war file


# FILE_LOCK=NO is supposed to stop locks being put on the DB but tomcat redeploy still fails with locked db errors
# Seems I should have picked this PostgreSQL thing instead of H2 which really doesn't seem to work well with tomcat.
# ;DB_CLOSE_DELAY=-1
# ;FILE_LOCK=NO
spring.datasource.username=${falc.account.db.username}
spring.datasource.password=${falc.account.db.password}
spring.datasource.url=jdbc:h2:file:${falc.account.db.location}/${falc.account.db.name};DB_CLOSE_ON_EXIT=TRUE;AUTO_SERVER=TRUE
spring.datasource.name=accounth2db
spring.datasource.driverClassName=org.h2.Driver

# tomcat crashes if this is not set - spring says it is not required as this is the default
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect

# never: prevents db init from data.sql
spring.sql.init.mode=never

# none: production use - no changes to DB to be made by the 'normal' application
spring.jpa.hibernate.ddl-auto=none 
spring.jpa.generate-ddl=false

# Start the H2 console: use http://localhost:8080/h2-console to access it
# WARNING: requires spring-boot-starter-web in pom although baeldung does not mention this...
# Does NOT work when running in tomcat.
# Tomcat needs the AUTO_SERVER=TRUE on the datasource URL.
# Finally got the H2 console - turns out '/h2-console' must be appended to 
# the URL of the account web application
# https://hostname:port/jaccountapi/h2-console
spring.h2.console.settings.web-allow-others=true
spring.h2.console.enabled=true
server.port=8080
server.servlet.context-path=


# Below are settings used to try to workaround the Access DB from being closed while in use.
# 
#spring.jpa.properties.hibernate.temp.use_jdbc_metadata_defaults=false
#spring.jpa.properties.hibernate.boot.allow_jdbc_metadata_access=false


# Try using the defaults for H2 db until some problem requires a modification
# HikariPool-1 - Connection net.ucanaccess.jdbc.UcanaccessConnection@4e83a42f[C:\\Development\\accountDB\\acc2003_TEST.mdb] marked as broken because of SQLSTATE(08503), ErrorCode(-1353)
# after period of inactivity. Need to somehow tell Hikari to reopen the connection or to keep it alive
# Needless to say I got these from Google and have no clue what they do or whether they will help!!
#spring.datasource.test-while-idle=true
## spring.datasource.validation-query=SELECT 1;
#spring.datasource.time-between-eviction-runs-millis=6000
#spring.datasource.remove-abandoned=true
#spring.datasource.remove-abandoned-timeout=60

# Documentation: 
# https://www.baeldung.com/spring-boot-hikari
# https://github.com/brettwooldridge/HikariCP?tab=readme-ov-file#gear-configuration-knobs-baby
#spring.datasource.hikari.connectionTimeout=30000
#spring.datasource.hikari.validationTimeout=5000
#spring.datasource.hikari.leakDetectionThreshold=10000
#spring.datasource.hikari.leak-detection-threshold=120000
#spring.datasource.hikari.maxLifetime=30001
#spring.datasource.hikari.idleTimeout=15000
# keepaliveTime >= 30000
#spring.datasource.hikari.keepaliveTime=30000

#spring.datasource.hikari.maximumPoolSize=5
#spring.datasource.hikari.minimumIdle=0


